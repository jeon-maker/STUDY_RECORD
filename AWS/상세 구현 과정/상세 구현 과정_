# 상세 구현 과정

## Network

![https://user-images.githubusercontent.com/77326600/233906535-bb20a2f2-3de4-4b25-a77d-a36e6d08b50f.png](https://user-images.githubusercontent.com/77326600/233906535-bb20a2f2-3de4-4b25-a77d-a36e6d08b50f.png)

**VPC를 만들었다.**

- VPC 안에 서브넷들을 만들었다.
    - PublicSubnet 2개와 그에 속한 PriavateSubnet 2개를 만들었다
    - 이때 고가용성 확보를 위해 서로 다른 서브넷에 두었다.
    
    ![Untitled](%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A6%20%E1%84%80%E1%85%AE%E1%84%92%E1%85%A7%E1%86%AB%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC%20882289bdb13f4bfb9e1257a3e14ec855/Untitled.png)
    

**RouteTable을 만들었다.**

- PublicRouteTable, PrivateRouteTable을 따로 두었다.
- PublicRouteTalbe에만 IGW를 달아두었다.
    - 모든 IP에서의 접근은 IGW로 향하게 한다 → 인터넷 연결 허용
    - 10.0.0.0/16 에서의 접근은 local로 향하게 한다 → 10.0.0.0/16 은 VPC 전체의 IP 주소이다. VPC에서의 접근은 VPC로 향하게 한다는 말이니까, 이것은 곧 VPC 내부의 요소들끼리 모두 연결시켜 준다는 것이다.

![Untitled](%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A6%20%E1%84%80%E1%85%AE%E1%84%92%E1%85%A7%E1%86%AB%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC%20882289bdb13f4bfb9e1257a3e14ec855/Untitled%201.png)

**********************IGW 이다.**********************

- 내가 만든 VPC와 연결이 되어있다.
- VPC의 PublicRouteTable와 연결을 해두었고, PublicRouteTable은 PublicSubnet과 연결이 되어있으므로 PublicSubnet 위에 인스턴스를 띄우면 인터넷 연결이 된다.

> VPC를 만들고 그것과 연결된 IGW를 만들었다. VPC 안에 퍼블릭 서브넷을 만들고, 퍼블릿 서브넷안에 인스턴스를 만들었다.  퍼블릭 서브넷을 관리하는 라우팅 테이블을 만들고, 그 테이블에서 0.0.0.0/0 → IGW를 해준다면 인스턴스가 인터넷 연결 가능해진다.
> 
- Q.블릭 라우팅 테이블에서 0.0.0.0/0 의 타겟을 IGW로 연결한다면 퍼블릭 라우팅 테이블에서 관리하는 요소들 뿐만 아니라 해당 VPC 내 모든 요소들이 인터넷 연결이 가능해진다?
    - A. Yes. 그러나 보안상 이유로 일부 요소들은 인터넷에 연결하지 않는것이 일반적.
        
        이를 위해서 프라이빗 서브넷과 퍼블릭 서브넷을 나누어 관리하고 프라이빗 서브넷에는 NAT 게이트웨이를 배치하여 인터넷에 연결함. ⇒ 이것은 비용 발생함.
        
        (Private을 사용하는것이 좋지만, 비용이 발생하기 때문에 프로젝트를 진행하는 동안은 Public에 모두 올려 사용합니다)
        

### 인스턴스

![Untitled](%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A6%20%E1%84%80%E1%85%AE%E1%84%92%E1%85%A7%E1%86%AB%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC%20882289bdb13f4bfb9e1257a3e14ec855/Untitled%202.png)

******WAS******

- Web Application Server 역할
- MySQL 모듈 연동, Redis 모듈 연동됨.
- 스크립트로 작성 (초기 세팅 스크립트)

```jsx
#! /bin/bash 
 
echo "==================================="
echo
echo "Apache install"
yum install -y httpd
 
echo "===================================="
echo
echo "PHP install"
amazon-linux-extras install -y php8.0
 
echo "===================================="
echo
echo "Apache-PHP-FPM Connect"
 
function fpm() {
     local before="proxy:unix:/run/php-fpm/www.sock|fcgi://localhost"
     local after="proxy:fcgi://127.0.0.1:9000"
     sed -i "s#$before#$after#g" /etc/httpd/conf.d/php.conf
}
fpm
sed -i "s#listen = /run/php-fpm/www.sock#listen = 9000#g" /etc/php-fpm.d/www.conf
 
echo "===================================="
echo
echo "Apache Start"
systemctl start httpd
systemctl enable httpd
systemctl status httpd
 
echo "===================================="
echo
echo "Test PHP Script"
cat <<EOF > /var/www/html/index.php
<?php
phpinfo();
?>
EOF
 
echo "===================================="
echo
echo "PHP-FPM Start"
systemctl start php-fpm
systemctl enable php-fpm
systemctl status php-fpm
 
echo "===================================="
echo
echo "APRM install & change config file Finish"
 
echo "==================================="
echo
echo "PHP REIDS Connect"
mkdir /phpredis
cd /phpredis
yum install -y php-devel
yum install -y gcc
wget https://github.com/nicolasff/phpredis/zipball/master -O phpredis.zip
unzip phpredis.zip
if [ -e phpredis-phpredis-* ]
then
     cd phpredis-phpredis-*
     phpize
     ./configure
     make && make install
else
     echo "Not Found"
     break
fi
cat <<EOF > /etc/php.d/predis.ini
extension=redis.so
EOF
php -m | grep -i redis
php -i | grep -i redis | grep -i version
sleep 3
function prc_1() {
        local before="php_value\[session.save_handler\] = files"
        local after="php_value[session.save_handler] = redis"
        sed -i "s#$before#$after#g" /etc/php-fpm.d/www.conf
}
prc_1
 
function prc_2() {
        local before="php_value\[session.save_path\]    = /var/lib/php/session"
        local after="php_value[session.save_path]    = tcp://127.0.0.1:6379"
        sed -i "s#$before#$after#g" /etc/php-fpm.d/www.conf
}
prc_2
 
systemctl restart php-fpm
systemctl status php-fpm

echo "===================================="
echo
echo "mysql install"
yum install -y mysql
systemctl start mysqld
systemctl enable mysqld
systemctl status mysqld

echo "===================================="
echo
echo "reboot"
reboot
```

### /var/www/html/test.php

```jsx
<html>

  <head>

    <title>Using Redis Server with PHP and MySQL</title>

  </head> 

  <body>

    <h1 align = 'center'>Employees' Register</h1>

    <table align = 'center' border = '2'>        

    <?php 

        try {

            $data_source = '';

            $redis = new Redis(); 

            $redis->connect('$redis_ip', 6379); 

            $sql = 'select

                    employee_id,

                    first_name,

                    last_name                                 

                    from employees

                    ';

            $cache_key = md5($sql);

            if ($redis->exists($cache_key)) {

                $data_source = "Data from Redis Server";

                $data = unserialize($redis->get($cache_key));

            } else { 

                $data_source = 'Data from MySQL Database';

                $db_name     = '$mysql_db';

                $db_user     = '$mysql_user';

                $db_password = '$mysql_pwd';

                $db_host     = '$mysql_ip';

                $pdo = new PDO('mysql:host=' . $db_host . '; dbname=' . $db_name, $db_user, $db_password);

                $pdo->setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);

                $stmt = $pdo->prepare($sql);

                $stmt->execute();

                $data = []; 

                while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {          

                   $data[] = $row;  

                }  

                $redis->set($cache_key, serialize($data)); 

                $redis->expire($cache_key, 10);        

           }

           echo "<tr><td colspan = '3' align = 'center'><h2>$data_source</h2></td></tr>";

           echo "<tr><th>Employee Id</th><th>First Name</th><th>Last Name</th></tr>";

           foreach ($data as $record) {

              echo '<tr>';

              echo '<td>' . $record['employee_id'] . '</td>';

              echo '<td>' . $record['first_name'] . '</td>';

              echo '<td>' . $record['last_name']  . '</td>';                     

              echo '</tr>'; 

           }              

        } catch (PDOException $e) {

            echo 'Database error. ' . $e->getMessage();

        }

   ?>

    </table>

  </body>

</html>
```

- 초기 접근시 MySQL 에서 Data를 가져오고 Redis에 캐시로 올려줌.
- Redis는 NoSQL이기 때문에 직렬화해서 Redis에 저장하고, 화면에 보여주기 위해서는 다시 역직렬화를 해서 MySQL에 저장된 원본 형태로 되돌려준다.

- MySQL 인스턴스와 Redis 인스턴스도 이렇게 스크립트로 설치하여 생성하였음.

WAS 접근하기.

![Untitled](%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A6%20%E1%84%80%E1%85%AE%E1%84%92%E1%85%A7%E1%86%AB%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC%20882289bdb13f4bfb9e1257a3e14ec855/Untitled%203.png)

접근한 기록이 있기 때문에 Redis 화면을 보여준다.

## ALB 생성하기

미리 만들어둔 보안그룹을 사용해서 ALB를 생성한다.

![Untitled](%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A6%20%E1%84%80%E1%85%AE%E1%84%92%E1%85%A7%E1%86%AB%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC%20882289bdb13f4bfb9e1257a3e14ec855/Untitled%204.png)

대상그룹을 설정한다.

![Untitled](%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A6%20%E1%84%80%E1%85%AE%E1%84%92%E1%85%A7%E1%86%AB%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC%20882289bdb13f4bfb9e1257a3e14ec855/Untitled%205.png)

HTTP, HTTPS 로 들어오는 요청들은 타겟 그룹에 보내준다.

이때, 타겟그룹이란 ALB가 관리하는 인스턴스들을 뜻한다.

- Q.ALB의 대상그룹에 속한 인스턴스들은 ALB가 관리하는 서브넷상에 위치해야 하나?
    - A.대상 그룹에 속한 인스턴스는 ALB가 관리하는 서브넷 뿐만 아니라, VPC 내에 위치한 모든 서브넷에서도 선택할 수 있습니다. 대상 그룹을 생성할 때 서브넷을 지정하면 해당 서브넷 내의 인스턴스만 대상 그룹에 추가됩니다. 그러나 대상 그룹에 속한 인스턴스가 위치한 서브넷이 ALB가 관리하는 서브넷과 다른 경우, 이를 연결하는 VPC 내에서 인터넷 게이트웨이 또는 NAT 게이트웨이를 통해 ALB와 통신할 수 있도록 구성해야 합니다.

![Untitled](%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A6%20%E1%84%80%E1%85%AE%E1%84%92%E1%85%A7%E1%86%AB%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC%20882289bdb13f4bfb9e1257a3e14ec855/Untitled%206.png)

ALB를 성공적으로 생성하였지만, 아직은 타겟 그룹안에 어떠한 인스턴스도 존재하지 않는다. 

********************ASG******************** 와 연동하여 쓰기 위해서 AMI를 만들어야 한다.

## AutoScaling , AMI , Launch Templates

![Untitled](%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A6%20%E1%84%80%E1%85%AE%E1%84%92%E1%85%A7%E1%86%AB%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC%20882289bdb13f4bfb9e1257a3e14ec855/Untitled%207.png)

AutoScaling 하기 위해 WAS로 쓰이는 인스턴스를 AMI로 만들었다!

( AMI는 인스턴스를 생성하기 위한 이미지!)

AutoScaling하기 위해서는 Launch Templates가 필요하다

************Launch Templates************

- AMI를 사용한다
- 버전 관리가 편하다
- ASG와 묶여 쓰인다.

![Untitled](%E1%84%89%E1%85%A1%E1%86%BC%E1%84%89%E1%85%A6%20%E1%84%80%E1%85%AE%E1%84%92%E1%85%A7%E1%86%AB%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC%20882289bdb13f4bfb9e1257a3e14ec855/Untitled%208.png)

런치 템플릿 생성!

WAS 이미지를 선택하여 템플릿을 생성하였다.

### To be continued…